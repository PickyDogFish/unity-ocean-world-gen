// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DoDFT

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _HeightTex;
RWTexture2D<float4> _NormalTex;
RWTexture2D<float4> _DisplacementTex;
Texture2D<float4> _TimeSpectrumTex;


static const float PI = 3.14f;
static const float g = 9.81f;
int _N; //fft size
float _Length; //length of mesh

float2 euler(float x){
    return float2(cos(x), sin(x));
}

float2 complexMultiply(float2 a, float2 b){
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

[numthreads(8,8,1)]
void DoDFT(uint3 id : SV_DispatchThreadID)
{
    float h = 0.0f;
    float3 normal = 0.0f;
    float2 displacement = 0.0f;
    for (int i = 0; i < _N; i++){
        for (int j = 0; j < _N; j++){
            float2 timeSpectrum = _TimeSpectrumTex[uint2(i,j)].xy;

            float2 k = (float2(i, j) - float2(_N/2.0f, _N/2.0f)) * PI / _Length;
            float kLen = length(k);

            float2 eulerkx = euler(dot(k, id.xy));
            float2 hxt = complexMultiply(timeSpectrum, eulerkx);
            
            h += hxt.x;
            normal += float3(-k.x * hxt.y, 0.0f, -k.y * hxt.y);

            if (kLen > 0.0001f)
                displacement += k / kLen * hxt.y/_Length;
        }
    }
    _HeightTex[id.xy] = float4(h,1,1,1);
    _NormalTex[id.xy] = normalize(float4(-normal.x, 1, -normal.z, 0));
    _DisplacementTex[id.xy] = float4(displacement, 0, 0);
}
