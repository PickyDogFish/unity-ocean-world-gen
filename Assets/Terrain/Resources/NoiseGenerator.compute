// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel NoiseTexture
#pragma kernel HeightData
#pragma kernel SplatData

#include "psrdnoise2d.hlsl" //https://github.com/stegu/webgl-noise converted to hlsl

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> _noiseValues;

uint _size;
float _scale;
int2 _tileCoords;
float _percentUnderwater;

const static float2x2 factorMat2 = float2x2(0.8,-0.6,0.6,0.8);



float getNoise(int2 coords){
    return Unity_GradientNoise_float(coords.xy/(float)_size);
}

float getFractalNoise(int2 coords, float H, int numOctaves)
{    
    float G = exp2(-H);
    float frequency = 1.0;
    float amplitude = 1.0;
    float ampSum = 0;
    float t = 0.0;
    for( int i=0; i<numOctaves; i++ )
    {
        t += amplitude*getNoise(frequency*coords);
        frequency *= 2.0;
        ampSum += amplitude;
        amplitude *= G;
    }
    return t / ampSum;
}

float getMorphedGradientNoise(int2 coords){
    float2 newCoords = coords.xy/(float)_size;
    float noise1 = Unity_GradientNoise_float(newCoords);
    newCoords = newCoords + noise1.xx;
    float noise2 = Unity_GradientNoise_float(newCoords);
    return noise2;
}

float getMorphedValueNoise(float2 coords){
    float2 newCoords = coords;
    float3 noise = myValueNoise(newCoords);
    newCoords = newCoords + noise.xx;
    noise = myValueNoise(newCoords);
    newCoords = newCoords + noise.xx;
    noise = myValueNoise(newCoords);
    return noise.x;
}

float getMorphedSimplexNoise(float2 coords){
    float2 newCoords = coords;
    float noise = sdnoise01(newCoords).x;
    newCoords = newCoords + noise.xx;
    noise = sdnoise01(newCoords).x;
    newCoords = newCoords + noise.xx;
    noise = sdnoise01(newCoords).x;
    return noise;
}


float valueNoiseFBM(float2 coords, float H, int numOctaves)
{   
    float G = exp2(-H);
    float frequency = 1.0;
    float amplitude = 1.0;
    float ampSum = 0;
    float t = 0.0;
    for( int i=0; i<numOctaves; i++ )
    {
        t += myValueNoise(coords * frequency).x * amplitude;
        frequency *= 2.0;
        ampSum += amplitude;
        amplitude *= G;
    }
    return t / ampSum;
}

float MorphedFBMNoise(float2 coords, float H, int numOctaves){
    float noise = valueNoiseFBM(coords, H, numOctaves);
    float2 newCoords = coords + noise.xx;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    newCoords = newCoords + noise.xx;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    newCoords = newCoords + noise.xx*4;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    return noise;
}

//from https://iquilezles.org/articles/morenoise/
// returns 3D fbm and its 3 derivatives
float3 fbm(float2 x, uint octaves)
{
    float freq = 2;  // could be 2.0
    float valueSum = 0.0;
    float amplitude = 0.6;
    float2 derivatives = 0.0;
    float3 n = 0;

    for(uint i=0; i < octaves; i++ )
    {
        n = sdnoise((x+n.xx/(10.0 * ((i*2)+1))) * freq);
        derivatives += amplitude * n.yz;      // accumulate derivatives
        valueSum += amplitude * n.x / (1.0+ dot(derivatives,derivatives));          // accumulate values
        amplitude *= 0.55;
        //x = freq * mul(factorMat2,x) + n.yz;
        freq *= 1.9;
    }
    return float3( valueSum *0.5 + 0.5, derivatives);
}

float3 getNoiseWrapper(int2 coords){
    float2 floatCoords = coords.xy/(float)_size * _scale;
    //return MorphedFBMNoise(floatCoords, 1.5, 4);
    //return fbm(floatCoords, 8);
    //return myFbmValueNoise(floatCoords * 5, 8);
    return myMorphedFbmNoise(floatCoords*5);
    //return getMorphedValueNoise(coords);
    //return myValueNoise(floatCoords.xy * 20);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int2 coords = _tileCoords * (_size-1) + id.xy;
    _noiseValues[id.y * _size + id.x] = getNoiseWrapper(coords).x;


    //As size is n^2 + 1, we have to handle the edge cases here
    if (id.x == _size-2){
        _noiseValues[id.y * _size + id.x + 1] = getNoiseWrapper(coords.xy + int2(1,0)).x;
    }
    if (id.y == _size-2){
        _noiseValues[(id.y + 1) * _size + id.x] = getNoiseWrapper(coords.xy + int2(0,1)).x;
    }
    if (id.y == _size-2 && id.x == _size-2){
        _noiseValues[(id.y + 1) * _size + id.x + 1] = getNoiseWrapper(coords.xy + int2(1,1)).x;
    }
}


RWTexture2D<float4> _noiseTexture;

[numthreads(8,8,1)]
void NoiseTexture(uint3 id : SV_DispatchThreadID)
{
    int2 coords = _tileCoords * (_size-1) + id.xy;
    float3 noise = getNoiseWrapper(coords);
    noise.x = noise.x/2;
    //TESTING
    //float steepness = length(noise.yz)/5;
    //float steepness = (sqrt(noise.y * noise.y + noise.z * noise.z));
    //noise.y = steepness;
    //noise = abs(noise);
    //END TESTING
    _noiseTexture[id.xy] = float4(noise,1);
    if (id.x == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(1,0));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(1,0)] = float4(noise,1);
    }
    if (id.y == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(0,1));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(0,1)] = float4(noise,1);
    }
    if (id.y == _size-2 && id.x == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(1,1));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(1,1)] = float4(noise,1);
    }
}





RWTexture2D<float4> _heightMap;
RWTexture2D<float4> _splatMap;


void SetHeightDataAt(uint2 id){
    int2 coords = _tileCoords * (_size-1) + id.xy;
    float3 noise = getNoiseWrapper(coords);
    //_splatMap[id] = CalculateSplatMap(noise);
    
    noise.x = noise.x/2; //when setting the heightmap for terrain directly, it seems to expect range from 0-0.5;
    //noise = abs(noise);
    _heightMap[id] = float4(noise,1);
}

[numthreads(8,8,1)]
void HeightData(uint3 id : SV_DispatchThreadID)
{
    SetHeightDataAt(id.xy);
    if (id.x == _size-2){
        SetHeightDataAt(id.xy + uint2(1,0));
    }
    if (id.y == _size-2){
        SetHeightDataAt(id.xy + uint2(0,1));
    }
    if (id.y == _size-2 && id.x == _size-2){
        SetHeightDataAt(id.xy + uint2(1,1));
    }
}


float3 CalcNormal(uint2 id){
    // # P.xy store the position for which we want to calculate the normals
    // # height() here is a function that return the height at a point in the terrain

    // read neightbor heights using small offset
    int2 off = int2(1, 0);
    float hR;
    if (id.x == _size-1){
        hR = getNoiseWrapper(_tileCoords * (_size-1) + id.xy + off.xy).x/2;
    } else {
        hR = _heightMap[id + off.xy].x;
    }

    float hU;
    if (id.y == _size-1){
        hU = getNoiseWrapper(_tileCoords * (_size-1) + id.xy + off.yx).x/2;
    } else {
        hU = _heightMap[id + off.yx].x;
    }
    float hID = _heightMap[id].x;

    // deduce terrain normal
    float3 N;
    N.x = hID - hR;
    N.y = 1.0/16384.0;
    N.z = hID - hU;
    return normalize(N);
}

float4 sumOne(float4 input){
    return input / (input.x + input.y + input.z + input.w);
}

void SetSplatDataAt(uint2 id){
    float3 normal = CalcNormal(id);
    float height = _heightMap[id].x;
    float steepness = betterSmooth(normal.y);
    float sandMask = saturate(-(height-_percentUnderwater/2 - 0.002)*1000) * steepness*2;
    float grassMask = saturate((height-_percentUnderwater/2 - 0.002)*1000) * steepness*2;
    float rockMask = 1-steepness;
    float snowMask = saturate((height - 0.45)*100) * steepness; 
    float4 map =  float4(snowMask,rockMask,grassMask, sandMask); 
    _splatMap[id] = sumOne(map);

}

[numthreads(8,8,1)]
void SplatData(uint3 id : SV_DispatchThreadID){
    SetSplatDataAt(id.xy);
    if (id.x == _size-2){
        SetSplatDataAt(id.xy + uint2(1,0));
    }
    if (id.y == _size-2){
        SetSplatDataAt(id.xy + uint2(0,1));
    }
    if (id.y == _size-2 && id.x == _size-2){
        SetSplatDataAt(id.xy + uint2(1,1));
    }
}


