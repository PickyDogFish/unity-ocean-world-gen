// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DoMath

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _HeightTex;


static const float PI = 3.14f;
static const float g = 9.81;
static const float A = 0.1;
int N = 128; //fft size
float NekiTest = 128.0f;
float len = 128.0f; //length of mesh
float2 wind = float2(25,7);
float _Time = 0.3;

float phillips(int n_prime, int m_prime) {
    float2 k = (float2(n_prime, m_prime) - float2(N/2.0f, N/2.0f)) * PI / len;
    float k_length = length(k);
    if (k_length < 0.000001) return 0.0;
 
    float k_length2 = k_length * k_length;
    float k_length4 = k_length2 * k_length2;
 
    float k_dot_w = dot(normalize(k), normalize(wind));
    float k_dot_w2 = k_dot_w * k_dot_w;
 
    float w_length = length(wind);
    float L = w_length * w_length / g;
    float L2 = L * L;
     
    float damping = 0.001;
    float l2 = L2 * damping * damping;
 
    return A * exp(-1.0 / (k_length2 * L2)) / k_length4 * k_dot_w2 * exp(-k_length2 * l2);
}

float dispersion(int n_prime, int m_prime) {
    float w_0 = 2.0 * PI / 200.0;
    float kx = PI * (2 * n_prime - N) / len;
    float kz = PI * (2 * m_prime - N) / len;
    return floor(sqrt(g * sqrt(kx * kx + kz * kz)) / w_0) * w_0;
}

float2 rand_22(float2 uv) {
    float noiseX = (frac(sin(dot(uv, float2(12.9898,78.233) * 2.0)) * 43758.5453));
    float noiseY = sqrt(1 - noiseX * noiseX);
    return float2(noiseX, noiseY);
}

// htilde0(-k) does not return desired result
float2 htilde0(int n_prime, int m_prime){
    float2 random = rand_22(float2(n_prime/float(N), m_prime/float(N)));
    return random * sqrt(phillips(n_prime, m_prime)/2.0f);
}

float2 euler(float x){
    return float2(cos(x), sin(x));
}

float2 complexMultiply(float2 a, float2 b){
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 htilde(float t, int n_prime, int m_prime){
    float2 ht0 = complexMultiply(htilde0(n_prime, m_prime), euler(dispersion(n_prime, m_prime) * t));
    int modn = (n_prime - N) % N;
    int modm = (m_prime - N) % N;
    float2 ht01 = complexMultiply(htilde0(modn, modm), euler(-dispersion(n_prime, m_prime) * t));
    ht01.y = -ht01.y;
    return ht0 + ht01;
}




[numthreads(8,8,1)]
void DoMath(uint3 id : SV_DispatchThreadID)
{
    float h = 0.0f;
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            float2 htild = htilde(_Time, i, j);
            float2 hxt = complexMultiply(htild, euler(dot(float2(i,j), id.xy)));
            h += max(0,hxt.x);
        }
    }

    //_HeightTex[id.xy] = phillips(-id.x,-id.y);//float4(h,1,1,1);
    _HeightTex[id.xy] = float4(htilde(_Time, id.x,id.y),0,0);
    //_HeightTex[id.xy] = float4(h,1,1,1);
}
