// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateInitialSpectrum
#pragma kernel CalculateConjugatedSpectrum
#pragma kernel UpdateSpectrum

#include "GPURandom.hlsl"
#include "Oceanography.hlsl"
#include "ComplexMath.hlsl"

uint _Size;
float _WindSpeed, _Scale, _Depth, _FrameTime;


RWTexture2DArray<float4> _InitialSpectrum;
RWTexture2DArray<float4> _TimeSpectrum;
// wave vector x, chop, wave vector z, frequency

float NormalRandom(uint3 id)
{
	float2 random01 = hash23(id);
    return cos(2.0 * OCEANOGRAPHY_PI * random01.x) * sqrt(-2.0 * log(random01.y));
}


[numthreads(8,8,1)]
void CalculateInitialSpectrum(uint3 id : SV_DispatchThreadID)
{
    float halfN = _Size /2.0f;

    float deltaK = 2.0f * OCEANOGRAPHY_PI / _Scale;

    float2 k = (id.xy - halfN) * deltaK;

    // the last +5 is random
    float2 noise = float2(NormalRandom(id), NormalRandom(uint3(id.x * id.x, id.y * id.y, id.z * id.z)));
    float kLength = length(k);
    float omega = Frequency(kLength, _Depth);
    float peakOmega = PiersonMoskowitzPeakOmega(_WindSpeed);
    float kAngle = atan2(k.y, k.x);
    //float db = DonelanBanner(kAngle, omega, peakOmega);
    float spectrum = PiersonMoskowitz(omega, peakOmega) * DirectionSpectrum(kAngle, omega, peakOmega) * ShortWavesFade(kLength);

    //float lambda = 0.5;//Chop * eq.g;
    //WavesData[id] = float4(k.x, lambda, k.y, omega);

    _InitialSpectrum[id] = float4(noise * spectrum, 1, 1);
}


[numthreads(8, 8, 1)]
void CalculateConjugatedSpectrum(uint3 id : SV_DispatchThreadID)
{
    uint i = 0;
    float2 h0 = _InitialSpectrum.Load(uint3(id.xy, i)).xy;
    float2 h0c = _InitialSpectrum.Load(uint3((_Size - id.x) % _Size, (_Size - id.y) % _Size, i)).xy;

    _InitialSpectrum[id] = float4(h0, h0c.x, -h0c.y);
}



/* [numthreads(8, 8, 1)]
void UpdateSpectrum(uint3 id : SV_DISPATCHTHREADID) {
    float4 initialSignal = _InitialSpectrum.Load(id);
    float2 spectrum = initialSignal.xy;
    float2 spectrumConj = initialSignal.zw;

    float halfN = _Size / 2.0f;

    float n = id.x - halfN;
    float m = id.y - halfN;

    float2 K = float2(n, m) * 2.0f * OCEANOGRAPHY_PI / _Scale;
    float w_0 = 2.0f * OCEANOGRAPHY_PI / 200.0f;
    float dispersion = floor(sqrt(9.8f * length(K)) / w_0) * w_0 * _FrameTime;

    _TimeSpectrum[uint3(id.xy, 0)] = float4(ComplexMult(spectrum, EulerFormula(dispersion)) + ComplexMult(spectrumConj, EulerFormula(-dispersion)), 0, 0);
} */



[numthreads(8, 8, 1)]
void UpdateSpectrum(uint3 id : SV_DISPATCHTHREADID) {
    int i = 0;
    float _RepeatTime = 200;

    float4 initialSignal = _InitialSpectrum[uint3(id.xy, i)];
    float2 h0 = initialSignal.xy;
    float2 h0conj = initialSignal.zw;

    float halfN = _Size / 2.0f;
    float2 K = (id.xy - halfN) * 2.0f * OCEANOGRAPHY_PI / _Scale;
    float kMag = length(K);
    float kMagRcp = rcp(kMag);

    if (kMag < 0.0001f) {
        kMagRcp = 1.0f;
    }

    float w_0 = 2.0f * OCEANOGRAPHY_PI / _RepeatTime;
    float dispersion = floor(sqrt(gravity * kMag) / w_0) * w_0 * _FrameTime;

    float2 exponent = EulerFormula(dispersion);

    float2 htilde = ComplexMult(h0, exponent) + ComplexMult(h0conj, float2(exponent.x, -exponent.y));
    float2 ih = float2(-htilde.y, htilde.x);

    float2 displacementX = ih * K.x * kMagRcp;
    float2 displacementY = htilde;
    float2 displacementZ = ih * K.y * kMagRcp;

    float2 displacementX_dx = -htilde * K.x * K.x * kMagRcp;
    float2 displacementY_dx = ih * K.x;
    float2 displacementZ_dx = -htilde * K.x * K.y * kMagRcp;

    float2 displacementY_dz = ih * K.y;
    float2 displacementZ_dz = -htilde * K.y * K.y * kMagRcp;

    float2 htildeDisplacementX = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);
    float2 htildeDisplacementZ = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x);
    
    float2 htildeSlopeX = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x);
    float2 htildeSlopeZ = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x);

    _TimeSpectrum[id] = float4(htildeDisplacementX, htildeDisplacementZ);
    //_TimeSpectrum[uint3(id.xy, i * 2 + 1)] = float4(htildeSlopeX, htildeSlopeZ);
    
}