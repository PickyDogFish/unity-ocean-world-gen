// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel NoiseTexture
#pragma kernel TerrainData

#include "psrdnoise2d.hlsl" //https://github.com/stegu/webgl-noise converted to hlsl

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> _noiseValues;

uint _size;
float _scale;
int2 _tileCoords;

const static float2x2 factorMat2 = float2x2(0.8,-0.6,0.6,0.8);



float getNoise(int2 coords){
    return Unity_GradientNoise_float(coords.xy/(float)_size);
}

float getFractalNoise(int2 coords, float H, int numOctaves)
{    
    float G = exp2(-H);
    float frequency = 1.0;
    float amplitude = 1.0;
    float ampSum = 0;
    float t = 0.0;
    for( int i=0; i<numOctaves; i++ )
    {
        t += amplitude*getNoise(frequency*coords);
        frequency *= 2.0;
        ampSum += amplitude;
        amplitude *= G;
    }
    return t / ampSum;
}

float getMorphedGradientNoise(int2 coords){
    float2 newCoords = coords.xy/(float)_size;
    float noise1 = Unity_GradientNoise_float(newCoords);
    newCoords = newCoords + noise1.xx;
    float noise2 = Unity_GradientNoise_float(newCoords);
    return noise2;
}

float getMorphedValueNoise(float2 coords){
    float2 newCoords = coords;
    float noise = Unity_SimpleNoise_float(newCoords);
    newCoords = newCoords + noise.xx;
    noise = Unity_SimpleNoise_float(newCoords);
    newCoords = newCoords + noise.xx;
    noise = Unity_SimpleNoise_float(newCoords);
    return noise;
}

float getMorphedSimplexNoise(float2 coords){
    float2 newCoords = coords;
    float noise = sdnoise01(newCoords).x;
    newCoords = newCoords + noise.xx;
    noise = sdnoise01(newCoords).x;
    newCoords = newCoords + noise.xx;
    noise = sdnoise01(newCoords).x;
    return noise;
}


float valueNoiseFBM(float2 coords, float H, int numOctaves)
{   
    float G = exp2(-H);
    float frequency = 1.0;
    float amplitude = 1.0;
    float ampSum = 0;
    float t = 0.0;
    for( int i=0; i<numOctaves; i++ )
    {
        t += amplitude*Unity_SimpleNoise_float(frequency*coords);
        frequency *= 2.0;
        ampSum += amplitude;
        amplitude *= G;
    }
    return t / ampSum;
}

float MorphedFBMNoise(float2 coords, float H, int numOctaves){
    float noise = valueNoiseFBM(coords, H, numOctaves);
    float2 newCoords = coords + noise.xx;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    newCoords = newCoords + noise.xx;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    newCoords = newCoords + noise.xx*4;
    noise = valueNoiseFBM(newCoords, H, numOctaves);
    return noise;
}

//from https://iquilezles.org/articles/morenoise/
// returns 3D fbm and its 3 derivatives
float3 fbm(float2 x, uint octaves)
{
    float freq = 2;  // could be 2.0
    float valueSum = 0.0;
    float amplitude = 0.6;
    float2 derivatives = 0.0;
    float3 n = 0;

    for(uint i=0; i < octaves; i++ )
    {
        n = sdnoise((x+n.xx/(10.0 * ((i*2)+1))) * freq);
        derivatives += amplitude * n.yz;      // accumulate derivatives
        valueSum += amplitude * n.x / (1.0+ dot(derivatives,derivatives));          // accumulate values
        amplitude *= 0.55;
        //x = freq * mul(factorMat2,x) + n.yz;
        freq *= 1.9;
    }
    return float3( valueSum *0.5 + 0.5, derivatives);
}

float3 getNoiseWrapper(int2 coords){
    float2 floatCoords = coords.xy/(float)_size * _scale;
    //return MorphedFBMNoise(floatCoords, 1.5, 4);
    return fbm(floatCoords, 8);
    //return getMorphedValueNoise(coords);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int2 coords = _tileCoords * (_size-1) + id.xy;
    _noiseValues[id.y * _size + id.x] = getNoiseWrapper(coords).x;


    //As size is n^2 + 1, we have to handle the edge cases here
    if (id.x == _size-2){
        _noiseValues[id.y * _size + id.x + 1] = getNoiseWrapper(coords.xy + int2(1,0)).x;
    }
    if (id.y == _size-2){
        _noiseValues[(id.y + 1) * _size + id.x] = getNoiseWrapper(coords.xy + int2(0,1)).x;
    }
    if (id.y == _size-2 && id.x == _size-2){
        _noiseValues[(id.y + 1) * _size + id.x + 1] = getNoiseWrapper(coords.xy + int2(1,1)).x;
    }
}


RWTexture2D<float4> _noiseTexture;

[numthreads(8,8,1)]
void NoiseTexture(uint3 id : SV_DispatchThreadID)
{
    int2 coords = _tileCoords * (_size-1) + id.xy;
    float3 noise = getNoiseWrapper(coords);
    noise.x = noise.x/2;
    //TESTING
    //float steepness = length(noise.yz)/5;
    //float steepness = (sqrt(noise.y * noise.y + noise.z * noise.z));
    //noise.y = steepness;
    //END TESTING
    _noiseTexture[id.xy] = float4(noise,1);
    if (id.x == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(1,0));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(1,0)] = float4(noise,1);
    }
    if (id.y == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(0,1));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(0,1)] = float4(noise,1);
    }
    if (id.y == _size-2 && id.x == _size-2){
        float3 noise = getNoiseWrapper(coords.xy + int2(1,1));
        noise.x = noise.x/2;
        _noiseTexture[id.xy + uint2(1,1)] = float4(noise,1);
    }
}





RWTexture2D<float4> _heightMap;
RWTexture2D<float4> _splatMap;

float4 CalculateSplatMap(float3 noise){
    float steepness = saturate(length(float2(-noise.y, noise.z)));// abs(noise.z);//sqrt(noise.y * noise.y + noise.z * noise.z);
    if (noise.x < 0.5){
        return float4(0,0,0,1);
    } else if (noise.x < 0.75){
        return float4(0,1-steepness,steepness,0);    
    } else {
        return float4(1-steepness,steepness,0,0);    
    }
}

void SetTerrainDataAt(uint2 id){
    int2 coords = _tileCoords * (_size-1) + id.xy;
    float3 noise = getNoiseWrapper(coords);
    _splatMap[id] = CalculateSplatMap(noise);
    
    noise.x = noise.x/2; //when setting the heightmap for terrain directly, it seems to expect range from 0-0.5;

    _heightMap[id] = float4(noise,1);
}

[numthreads(8,8,1)]
void TerrainData(uint3 id : SV_DispatchThreadID)
{
    SetTerrainDataAt(id.xy);
    if (id.x == _size-2){
        SetTerrainDataAt(id.xy + uint2(1,0));
    }
    if (id.y == _size-2){
        SetTerrainDataAt(id.xy + uint2(0,1));
    }
    if (id.y == _size-2 && id.x == _size-2){
        SetTerrainDataAt(id.xy + uint2(1,1));
    }
}


